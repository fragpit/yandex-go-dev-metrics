package main

import (
	"fmt"
	"go/ast"
	"log"
	"os"
	"path/filepath"
	"strings"
	"text/template"

	"golang.org/x/tools/go/packages"
)

const genFileName = "/reset.gen.go"

var tpl = `// Code generated by cmd/reset DO NOT EDIT
package {{ .PkgName }}

import "reflect"

{{- range .StructNames }}

func ({{ .ReceiverName }} *{{ .Name }}) Reset() {
    if {{ .ReceiverName }} == nil {
        return
    }

    v := reflect.ValueOf({{ .ReceiverName }}).Elem()
    resetValue(v)
}
{{- end }}

func resetValue(v reflect.Value) {
    if !v.IsValid() || !v.CanSet() {
        return
    }

    switch v.Kind() {
    case reflect.Ptr:
        if !v.IsNil() {
            resetValue(v.Elem())
        }
    case reflect.Struct:
        if resetter, ok := v.Addr().Interface().(interface{ Reset() }); ok {
            resetter.Reset()
            return
        }
        for i := 0; i < v.NumField(); i++ {
            field := v.Field(i)
            if field.CanSet() {
                resetValue(field)
            }
        }
    case reflect.Slice:
        if v.Len() > 0 {
            v.SetLen(0)
        }
    case reflect.Map:
        if v.Len() > 0 {
            v.Clear()
        }
    case reflect.String:
        v.SetString("")
    case reflect.Bool:
        v.SetBool(false)
    case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:
        v.SetInt(0)
    case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
        v.SetUint(0)
    case reflect.Float32, reflect.Float64:
        v.SetFloat(0)
    case reflect.Complex64, reflect.Complex128:
        v.SetComplex(0)
    }
}
`

type data struct {
	PkgName     string
	StructNames []structInfo
}

type structInfo struct {
	Name         string
	ReceiverName string
}

func loadPackages(patterns []string) ([]*packages.Package, error) {
	cfg := &packages.Config{
		Mode: packages.NeedName | packages.NeedFiles |
			packages.NeedSyntax | packages.NeedTypes |
			packages.NeedTypesInfo,
	}

	pkgs, err := packages.Load(cfg, patterns...)
	if err != nil {
		return nil, fmt.Errorf("failed to load packages: %w", err)
	}

	if packages.PrintErrors(pkgs) > 0 {
		return nil, fmt.Errorf("packages contain errors")
	}

	return pkgs, nil
}

func findReceiverName(pkg *packages.Package, typeName string) string {
	for _, file := range pkg.Syntax {
		fileName := pkg.Fset.Position(file.Pos()).Filename
		if strings.HasSuffix(fileName, genFileName) {
			continue
		}

		for _, decl := range file.Decls {
			funcDecl, ok := decl.(*ast.FuncDecl)
			if !ok || funcDecl.Recv == nil || len(funcDecl.Recv.List) == 0 {
				continue
			}

			recv := funcDecl.Recv.List[0]
			var recvTypeName string

			switch t := recv.Type.(type) {
			case *ast.StarExpr:
				if ident, ok := t.X.(*ast.Ident); ok {
					recvTypeName = ident.Name
				}
			case *ast.Ident:
				recvTypeName = t.Name
			}

			if recvTypeName == typeName && len(recv.Names) > 0 {
				return recv.Names[0].Name
			}
		}
	}

	return strings.ToLower(typeName[:1])
}

func findStructsWithResetTag(pkgs []*packages.Package) map[string]data {
	pkgStructs := make(map[string]data)

	for _, pkg := range pkgs {
		if len(pkg.GoFiles) == 0 {
			continue
		}
		pkgDir := filepath.Dir(pkg.GoFiles[0])
		d := data{PkgName: pkg.Name}

		for _, file := range pkg.Syntax {
			ast.Inspect(file, func(n ast.Node) bool {
				genDecl, ok := n.(*ast.GenDecl)
				if !ok {
					return true
				}

				hasGenerateReset := false
				if genDecl.Doc != nil {
					for _, comment := range genDecl.Doc.List {
						if comment.Text == "// generate:reset" {
							hasGenerateReset = true
							break
						}
					}
				}

				if !hasGenerateReset {
					return true
				}

				for _, spec := range genDecl.Specs {
					typeSpec, ok := spec.(*ast.TypeSpec)
					if !ok {
						continue
					}

					structName := typeSpec.Name.Name
					receiverName := findReceiverName(pkg, structName)
					d.StructNames = append(d.StructNames, structInfo{
						Name:         structName,
						ReceiverName: receiverName,
					})
				}

				return true
			})
		}

		if len(d.StructNames) > 0 {
			pkgStructs[pkgDir] = d
		}
	}

	return pkgStructs
}

func generateResetFiles(pkgStructs map[string]data) error {
	for pkgPath, data := range pkgStructs {
		if err := processPackage(pkgPath, data); err != nil {
			return fmt.Errorf("failed to process package %s: %w", pkgPath, err)
		}
	}
	return nil
}

//go:generate go run . ../../...
func main() {
	patterns := []string{"./..."}
	if len(os.Args) > 1 {
		patterns = os.Args[1:]
	}

	pkgs, err := loadPackages(patterns)
	if err != nil {
		log.Fatalf("failed to load packages: %v", err)
	}

	pkgStructs := findStructsWithResetTag(pkgs)

	if err := generateResetFiles(pkgStructs); err != nil {
		log.Fatalf("failed to generate reset files: %v", err)
	}
}

func processPackage(path string, data data) error {
	f, err := os.Create(path + genFileName)
	if err != nil {
		return err
	}

	t := template.Must(template.New("reset").Parse(tpl))
	if err := t.Execute(f, data); err != nil {
		return fmt.Errorf("failed to execute template: %w", err)
	}

	return nil
}
